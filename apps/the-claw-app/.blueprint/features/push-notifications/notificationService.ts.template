/**
 * Notification Service
 *
 * Server-side service for sending push notifications via Expo Push Service
 *
 * Usage:
 * ```typescript
 * import { sendPushNotification, sendBatchNotifications } from './notificationService';
 *
 * // Single notification
 * await sendPushNotification({
 *   to: 'ExponentPushToken[...]',
 *   title: 'New Message',
 *   body: 'You have a new message!',
 *   data: { screen: 'Messages', messageId: '123' },
 * });
 *
 * // Batch notifications
 * await sendBatchNotifications([
 *   { to: 'ExponentPushToken[...]', title: 'Hello', body: 'World' },
 *   { to: 'ExponentPushToken[...]', title: 'Hello', body: 'Again' },
 * ]);
 * ```
 *
 * Note: This file is for server-side use (Node.js, Edge Functions, etc.)
 * Do NOT use in React Native client (exposes sensitive logic)
 */

import { Expo, ExpoPushMessage, ExpoPushTicket } from 'expo-server-sdk';

// Create Expo SDK client
const expo = new Expo();

export interface PushNotificationPayload {
  /**
   * Expo Push Token (ExponentPushToken[...])
   */
  to: string;

  /**
   * Notification title
   */
  title: string;

  /**
   * Notification body
   */
  body: string;

  /**
   * Additional data (for deep linking, etc.)
   */
  data?: Record<string, any>;

  /**
   * Sound (default, null, or custom sound file name)
   */
  sound?: 'default' | null | string;

  /**
   * Badge count (iOS only)
   */
  badge?: number;

  /**
   * Time to live (seconds)
   */
  ttl?: number;

  /**
   * Priority (default or high)
   */
  priority?: 'default' | 'high';

  /**
   * Notification channel ID (Android only)
   */
  channelId?: string;
}

/**
 * Send a single push notification
 *
 * @throws Error if token is invalid or notification fails to send
 */
export async function sendPushNotification(
  payload: PushNotificationPayload
): Promise<ExpoPushTicket> {
  // Validate token
  if (!Expo.isExpoPushToken(payload.to)) {
    throw new Error(`Invalid Expo Push Token: ${payload.to}`);
  }

  const message: ExpoPushMessage = {
    to: payload.to,
    sound: payload.sound ?? 'default',
    title: payload.title,
    body: payload.body,
    data: payload.data,
    badge: payload.badge,
    ttl: payload.ttl,
    priority: payload.priority ?? 'high',
    channelId: payload.channelId ?? 'default',
  };

  try {
    const chunks = expo.chunkPushNotifications([message]);
    const tickets: ExpoPushTicket[] = [];

    for (const chunk of chunks) {
      const ticketChunk = await expo.sendPushNotificationsAsync(chunk);
      tickets.push(...ticketChunk);
    }

    return tickets[0];
  } catch (error) {
    console.error('Error sending push notification:', error);
    throw error;
  }
}

/**
 * Send multiple push notifications in batch
 *
 * Automatically chunks notifications to respect Expo's rate limits
 *
 * @returns Array of tickets (one per notification)
 */
export async function sendBatchNotifications(
  payloads: PushNotificationPayload[]
): Promise<ExpoPushTicket[]> {
  // Filter out invalid tokens
  const validPayloads = payloads.filter((payload) => {
    if (!Expo.isExpoPushToken(payload.to)) {
      console.warn(`Skipping invalid token: ${payload.to}`);
      return false;
    }
    return true;
  });

  if (validPayloads.length === 0) {
    return [];
  }

  const messages: ExpoPushMessage[] = validPayloads.map((payload) => ({
    to: payload.to,
    sound: payload.sound ?? 'default',
    title: payload.title,
    body: payload.body,
    data: payload.data,
    badge: payload.badge,
    ttl: payload.ttl,
    priority: payload.priority ?? 'high',
    channelId: payload.channelId ?? 'default',
  }));

  try {
    // Chunk notifications (Expo recommends max 100 per request)
    const chunks = expo.chunkPushNotifications(messages);
    const tickets: ExpoPushTicket[] = [];

    for (const chunk of chunks) {
      const ticketChunk = await expo.sendPushNotificationsAsync(chunk);
      tickets.push(...ticketChunk);
    }

    return tickets;
  } catch (error) {
    console.error('Error sending batch notifications:', error);
    throw error;
  }
}

/**
 * Check notification receipts (to verify delivery)
 *
 * Call this after sending notifications to check if they were delivered
 *
 * @param ticketIds - Array of ticket IDs from sendPushNotification/sendBatchNotifications
 * @returns Map of receipt ID to receipt status
 */
export async function checkNotificationReceipts(ticketIds: string[]) {
  const receiptIdChunks = expo.chunkPushNotificationReceiptIds(ticketIds);
  const receipts: Map<string, any> = new Map();

  for (const chunk of receiptIdChunks) {
    try {
      const receiptChunk = await expo.getPushNotificationReceiptsAsync(chunk);

      for (const [receiptId, receipt] of Object.entries(receiptChunk)) {
        receipts.set(receiptId, receipt);

        // Log errors
        if (receipt.status === 'error') {
          console.error(`Error in receipt ${receiptId}:`, receipt.message);

          if (receipt.details?.error) {
            // Common errors:
            // - DeviceNotRegistered: Token is no longer valid (user uninstalled app)
            // - MessageTooBig: Notification payload too large
            // - MessageRateExceeded: Sending too many notifications too quickly
            console.error(`Error code: ${receipt.details.error}`);
          }
        }
      }
    } catch (error) {
      console.error('Error checking receipts:', error);
    }
  }

  return receipts;
}

/**
 * Send notification to multiple users
 *
 * @param userTokens - Map of user ID to Expo Push Token
 * @param notification - Notification payload (same for all users)
 * @returns Map of user ID to ticket
 */
export async function sendToMultipleUsers(
  userTokens: Map<string, string>,
  notification: Omit<PushNotificationPayload, 'to'>
): Promise<Map<string, ExpoPushTicket>> {
  const results = new Map<string, ExpoPushTicket>();

  const payloads: (PushNotificationPayload & { userId: string })[] = [];

  for (const [userId, token] of userTokens.entries()) {
    if (Expo.isExpoPushToken(token)) {
      payloads.push({
        ...notification,
        to: token,
        userId,
      });
    } else {
      console.warn(`Invalid token for user ${userId}: ${token}`);
    }
  }

  if (payloads.length === 0) {
    return results;
  }

  const tickets = await sendBatchNotifications(payloads);

  // Map tickets back to user IDs
  payloads.forEach((payload, index) => {
    results.set(payload.userId, tickets[index]);
  });

  return results;
}

/**
 * Common notification templates
 */
export const NotificationTemplates = {
  /**
   * New message notification
   */
  newMessage: (senderName: string, message: string, messageId: string) => ({
    title: `New message from ${senderName}`,
    body: message,
    data: { screen: 'Messages', messageId },
    sound: 'default' as const,
  }),

  /**
   * Reminder notification
   */
  reminder: (title: string, body: string) => ({
    title,
    body,
    data: { screen: 'Reminders' },
    sound: 'default' as const,
  }),

  /**
   * Achievement unlocked
   */
  achievement: (achievementName: string) => ({
    title: 'ðŸŽ‰ Achievement Unlocked!',
    body: achievementName,
    data: { screen: 'Achievements' },
    sound: 'default' as const,
  }),

  /**
   * Friend request
   */
  friendRequest: (userName: string, userId: string) => ({
    title: 'New Friend Request',
    body: `${userName} wants to connect with you`,
    data: { screen: 'Friends', userId },
    sound: 'default' as const,
  }),
};

/**
 * Validate Expo Push Token format
 */
export function isValidExpoPushToken(token: string): boolean {
  return Expo.isExpoPushToken(token);
}

/**
 * Example: Send notification from Supabase Edge Function
 *
 * ```typescript
 * // supabase/functions/send-notification/index.ts
 * import { sendPushNotification } from './notificationService.ts';
 *
 * Deno.serve(async (req) => {
 *   const { token, title, body, data } = await req.json();
 *
 *   try {
 *     const ticket = await sendPushNotification({
 *       to: token,
 *       title,
 *       body,
 *       data,
 *     });
 *
 *     return new Response(JSON.stringify({ success: true, ticket }), {
 *       headers: { 'Content-Type': 'application/json' },
 *     });
 *   } catch (error) {
 *     return new Response(JSON.stringify({ error: error.message }), {
 *       status: 500,
 *       headers: { 'Content-Type': 'application/json' },
 *     });
 *   }
 * });
 * ```
 */
